OriginalSize - DS = 256×192, GBA = 240×160 (manual)

SourceSize - IDirect3DTexture9* (src.tex or whatever texture bound)

OutputSize - IDirect3DSurface9* RT (GetDesc) // 256x192/512x384 usual default, must be per-pass object.

///////////////////////////////////////////////////////////////////////////

MATCH TIER :: INPUT/OUTPUT

A) .SLANG STRING SOURCE
B) .HLSL VS/PS
C) .SEMANTICS (index, name, offset, size, mask, indices)
D) .CONSTANT TABLES // names/registers 

//////////////////////////////////////////////////////////////////////////
slang-shaders/xbrz/xbrz-freescale.slang  SEMANTICS MAP:

FBO: VIEWPORT → VIEWPORT

Internal scaling: sx=1.000 sy=1.000 abs=0

Filter: NEAREST

Wrap: BORDER

pass_semantics_t::textures:
Index   Binding   Stage Mask     Notes
0       2         0x02           Source texture (PS-visible)  // sampler2D Source @ set=0,binding=2 → s0
1       0         0x00           unused
2       0         0x02332950     internal / unused
3       0         0x10           internal / unused
4       0         0x00           unused
5       7         0x30D          internal / unused

//cbuff
Name        Offset  Size        Type                         Notes
MVP         0       64 bytes     mat4                         global_MVP (VS b0 / c0–c3)

//Param (PUSH/PC)
Name        Offset  Size        Type
SourceSize  0       16          vec4
OutputSize  16      16          vec4

//HLSL VS
Name            Reg     Bytes
gl_HalfPixel    c4      16
global_MVP      c0–c3   64

//PS
Source              s0      sampler
params_SourceSize   c0      16
params_OutputSize   c1      16

///////////////////////////////////////////////////////////////////////

SLANG → HLSL TRANSLATION TABLE (xbrz-freescale)

layout(push_constant) uniform Push { … } params; ------------------> cbuffer Push { … }

vec4 SourceSize; --------------------------------------------------> float4 params_SourceSize : packoffset(c0);

vec4 OutputSize; --------------------------------------------------> float4 params_OutputSize : packoffset(c1);

layout(std140, set=0, binding=0) uniform UBO { mat4 MVP; } global; --> cbuffer UBO : register(b0) { row_major float4x4 global_MVP : packoffset(c0); }

#pragma stage vertex ------------------------------------------------> (SPIRV-Cross splits into vert_main() + main())

layout(location=0) in vec4 Position; -------------------------------> float4 Position : TEXCOORD0;

layout(location=1) in vec2 TexCoord; -------------------------------> float2 TexCoord : TEXCOORD1;

layout(location=0) out vec2 vTexCoord; -----------------------------> float2 vTexCoord : TEXCOORD0;

gl_Position --------------------------------------------------------> static float4 gl_Position;

gl_Position = global.MVP * Position; -------------------------------> gl_Position = mul(Position, global_MVP);

vTexCoord = TexCoord; ----------------------------------------------> vTexCoord = TexCoord;

(no SLANG equivalent) ----------------------------------------------> uniform float4 gl_HalfPixel;

(no SLANG equivalent) ----------------------------------------------> gl_Position.x -= gl_HalfPixel.x * gl_Position.w;

(no SLANG equivalent) ----------------------------------------------> gl_Position.y += gl_HalfPixel.y * gl_Position.w;

#pragma stage fragment ----------------------------------------------> (SPIRV-Cross splits into frag_main() + main())

layout(set=0, binding=2) uniform sampler2D Source; ------------------> uniform sampler2D Source; // bound to s0

texture(Source, uv).rgb --------------------------------------------> tex2D(Source, uv).xyz

#define P(x,y) texture(Source, coord + params.SourceSize.zw*vec2(x,y)).rgb
--------------------------------------------------------------------> (expanded to tex2D(Source, coord + params_SourceSize.zw * float2(x,y))).xyz

params.SourceSize.xy  (pixel dims) ---------------------------------> params_SourceSize.xy

params.SourceSize.zw  (1/pixel dims) -------------------------------> params_SourceSize.zw

vec2 scale = params.OutputSize.xy * params.SourceSize.zw; ----------> float2 scale = params_OutputSize.xy * params_SourceSize.zw;

vec2 pos = fract(vTexCoord * params.SourceSize.xy) - vec2(0.5); ----> float2 pos = frac(vTexCoord * params_SourceSize.xy) - 0.5.xx;

vec2 coord = vTexCoord - pos * params.SourceSize.zw; ---------------> float2 coord = vTexCoord - (pos * params_SourceSize.zw);

ivec4 blendResult = ivec4(BLEND_NONE,...); --------------------------> int4 blendResult = int4(0,0,0,0);

mix(a,b,t) ----------------------------------------------------------> lerp(a,b,t)

step(edge,x) --------------------------------------------------------> step(edge,x)   // same semantic

smoothstep(a,b,x) ---------------------------------------------------> smoothstep(a,b,x)  // same semantic

sign(x) -------------------------------------------------------------> sign(x)

fract(x) ------------------------------------------------------------> frac(x)

dot(a,b) ------------------------------------------------------------> dot(a,b)

sqrt(x) -------------------------------------------------------------> sqrt(x)

pow(x,y) ------------------------------------------------------------> pow(x,y)

FragColor = vec4(res, 1.0); -----------------------------------------> FragColor = float4(res, 1.0f);

void main() (fragment) ----------------------------------------------> void frag_main() + SPIRV_Cross_Output main(SPIRV_Cross_Input)

/////////////////////////////////////////////////////////////////////////

(CONSTANT TABLES / REGISTERS — from log)
VS: CT constants=2
- gl_HalfPixel    regset=2 reg=4   count=1 bytes=16
- global_MVP      regset=2 reg=0   count=4 bytes=64

PS: CT constants=3
- Source              regset=3 reg=0  count=1 bytes=4   (sampler)  // s0
- params_SourceSize   regset=2 reg=0  count=1 bytes=16  // c0
- params_OutputSize   regset=2 reg=1  count=1 bytes=16  // c1

