OriginalSize - DS = 256×192, GBA = 240×160 (manual)

SourceSize - IDirect3DTexture9* (src.tex or whatever texture bound)

OutputSize - IDirect3DSurface9* RT (GetDesc) // 256x192/512x384 usual default, must be per-pass object.

///////////////////////////////////////////////////////////////////////////

MATCH TIER :: INPUT/OUTPUT

A) .SLANG STRING SOURCE
B) .HLSL VS/PS
C) .SEMANTICS (index, name, offset, size, mask, indices)
D) .CONSTANT TABLES // names/registers 

//////////////////////////////////////////////////////////////////////////

slang-shaders/crt/crt-lottes.slang SEMANTICS MAP:

FBO:INPUT → INPUT

internal scaling: NONE (sx=0 sy=0 abs=0 fp=0 srgb=0)

Filter: NEAREST

Wrap: BORDER

pass_semantics_t::textures:                
Index	Binding	Stage Mask	Notes
0 2 0x02 Source texture (PS-visible) (THIS is the actual Source sampler binding)
1 0 0x00 unused
2 0 0x023BBD10 internal / unused
3 0 0x00 unused
4 0 0x00 unused
5 0 0x00 unused

//cbuff                                                             
Name	Offset	Size	Type                                      
CBUF UBO: bind=0 uniforms=3
[00] id='MVP' off=0 size=64 mat4
[01] id='OutputSize' off=64 size=16 vec4
[02] id='SourceSize' off=96 size=16 vec4

//Param          
[00] id='hardScan' off=0 size=4 float
[01] id='hardPix' off=4 size=4 float
[02] id='warpX' off=8 size=4 float
[03] id='warpY' off=12 size=4 float
[04] id='maskDark' off=16 size=4 float
[05] id='maskLight' off=20 size=4 float
[06] id='scaleInLinearGamma' off=24 size=4 float
[07] id='shadowMask' off=28 size=4 float
[08] id='brightBoost' off=32 size=4 float
[09] id='hardBloomPix' off=40 size=4 float
[10] id='hardBloomScan' off=36 size=4 float
[11] id='bloomAmount' off=44 size=4 float
[12] id='shape' off=48 size=4 float

//HLSL VS
Name	Reg	Bytes
CT VS constants=2
gl_HalfPixel c4 16
global_MVP c0–c3 64

//PS
CT PS constants=16
Source s0 sampler
global_OutputSize c13 16
global_SourceSize c1 16
params_bloomAmount c13 4
params_brightBoost c10 4
params_hardBloomPix c12 4                          (CT shows global_OutputSize and params_bloomAmount both at reg=13
params_hardBloomScan c11 4                                        Treat “reg” as the base register) 
params_hardPix c3 4
params_hardScan c2 4
params_maskDark c6 4
params_maskLight c7 4
params_scaleInLinearGamma c8 4
params_shadowMask c9 4
params_shape c14 4
params_warpX c4 4
params_warpY c5 4        




///////////////////////////////////////////////////////////////////////

SLANG → HLSL TRANSLATION TABLE (crt lottes)
layout(push_constant) uniform Push { … } params; ------------------> cbuffer Push { … } // scalars packed via packoffset into c0..c3

float hardScan; ------------------> float params_hardScan : packoffset(c0);
float hardPix; ------------------> float params_hardPix : packoffset(c0.y);
float warpX; ------------------> float params_warpX : packoffset(c0.z);
float warpY; ------------------> float params_warpY : packoffset(c0.w);

float maskDark; ------------------> float params_maskDark : packoffset(c1);
float maskLight; ------------------> float params_maskLight : packoffset(c1.y);
float scaleInLinearGamma; ------------------> float params_scaleInLinearGamma : packoffset(c1.z);
float shadowMask; ------------------> float params_shadowMask : packoffset(c1.w);

float brightBoost; ------------------> float params_brightBoost : packoffset(c2);
float hardBloomScan; ------------------> float params_hardBloomScan : packoffset(c2.y);
float hardBloomPix; ------------------> float params_hardBloomPix : packoffset(c2.z);
float bloomAmount; ------------------> float params_bloomAmount : packoffset(c2.w);
float shape; ------------------> float params_shape : packoffset(c3);

#pragma parameter … ------------------> (RetroArch UI only; not shader codegen)

layout(std140,set=0,binding=0) uniform UBO { MVP; OutputSize; OriginalSize; SourceSize; } global; ------------------> cbuffer UBO : register(b0)
mat4 MVP; ------------------> row_major float4x4 global_MVP : packoffset(c0);
vec4 OutputSize; ------------------> float4 global_OutputSize : packoffset(c4);
vec4 OriginalSize; ------------------> float4 global_OriginalSize : packoffset(c5);
vec4 SourceSize; ------------------> float4 global_SourceSize : packoffset(c6);

layout(location=0) in vec4 Position; ------------------> float4 Position : TEXCOORD0;
layout(location=1) in vec2 TexCoord; ------------------> float2 TexCoord : TEXCOORD1;
layout(location=0) out vec2 vTexCoord; ------------------> float2 vTexCoord : TEXCOORD0;

gl_Position = global.MVP * Position; ------------------> gl_Position = mul(Position, global_MVP);

(no SLANG equivalent) ------------------> uniform float4 gl_HalfPixel;
(no SLANG equivalent) ------------------> gl_Position.x -= gl_HalfPixel.x * gl_Position.w;
(no SLANG equivalent) ------------------> gl_Position.y += gl_HalfPixel.y * gl_Position.w;

layout(set=0,binding=2) uniform sampler2D Source; ------------------> uniform sampler2D Source; // bound to s0

texture(Source,pos.xy) ------------------> tex2D(Source, pos).xyz // after SPIRV-Cross

global.SourceSize.xy ------------------> global_SourceSize.xy
global.OutputSize.zw ------------------> global_OutputSize.zw

KEY SPACE REQUIREMENT (THIS ONE MATTERS):
vTexCoord is treated as normalized UV for sampling, BUT the mask path does:
vTexCoord / global.OutputSize.zw ------------------> (vTexCoord * OutputSize.xy)
Therefore: OutputSize.zw MUST be (1/OutputW, 1/OutputH) for the mask math to land in pixel space correctly.

Fetch(): (floor(pos*SourceSize + off)+0.5)/SourceSize ------------------> exact same expression in HLSL using global_SourceSize.xy and tex2D

Warp(pos): pos in 0..1 -> map to -1..1 warp -> back to 0..1 ------------------> same math in HLSL

ToLinear/ToSrgb conditionally bypassed when scaleInLinearGamma==0 ------------------> same in HLSL

FragCoord exists in SLANG interface ------------------> SPIRV-Cross adds TEXCOORD1 FragCoord input, but in your shown HLSL it is not used in the executed path

FragColor = vec4(ToSrgb(outColor),1.0) ------------------> FragColor = float4(ToSrgb(outColor), 1.0f)

